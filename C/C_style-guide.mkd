The C Programming Style Guide
=============================

TL;DR
-----

Below is a simple program that demonstrates my C style (for more detail, read the rest of the guide):

```c
////////////////////////////////////////////////////////////////////////////////
// Comments

// This is simple C program that demonstrates my preferred C coding style.

////////////////////////////////////////////////////////////////////////////////
// Libraries

#include <stdio.h>
#include <math.h>

////////////////////////////////////////////////////////////////////////////////
// Symbolic Constants

#define FALSE 0
#define TRUE 1

////////////////////////////////////////////////////////////////////////////////
// Macros

#define PrintExpr (x) (printf ("PrintExpr:\n\t%s = [%d]\n", #x, (x)))

////////////////////////////////////////////////////////////////////////////////
// External Variables

int x = 1; // The first integer to add in the print_test function.

////////////////////////////////////////////////////////////////////////////////
// Function Prototypes

void print_test (int y, int z);
/* Prints out x + y + z twice: 1) prints the sums of the input in the argument section of the printf function 2) does the same, but lets a macro do the "heavy" lifting instead.

   `x` = The first integer to be added (is external).

   `y` = The second integer to be added (parameterized). And sometimes I write
   lots and lots and lots.

   `z` = The third integer to be added (parameterized). */

////////////////////////////////////////////////////////////////////////////////
// Functions

void print_test (int y, int z) {
	extern int x;

	printf ("printf:\n\tx + y + z = [%d]\n", x + y + z);
	PrintExpr (x + y + z);
}

////////////////////////////////////////////////////////////////////////////////
int main (void) {
	int * y, z; // I fully realize how silly it is to make y into a pointer here.

	// Sets y
	for (*y = 0; *y < 9; ++(*y)); // note how precedence is handled in expr3

	// Sets z {{{
	while (z != 90) {
		if (z < 80)
			z = z + 10;
		else if (z >= 80)
			++z;
		else if (z > 90)
			--z;
	}
	// }}}

	// Prints x + y + z
	print_test (*y, z);

	// Prints the result of an arbitrary, complex expression
	printf ("%f\n", 3 + 4 sin(fabs(x)) * (log(10) / pow(2, 3)));

	return 0;
}
```

Variables & Arrays
------------------

*	Declarations should have a space between the function declaration. E.G.

	```c
	char s[] = "Hello"; // String
	```

*	Pointers should be declared in the form of

	```c
	type * var;
	```

	For example:

	```c
	char * c;
	```

	I have a number of reasons for this:
	*	It can be easily read backwards, per the example above, as "c points to a char".
	*	This form actually makes sense (compare it to the K & R style, which is ambiguous as all hell when it comes to dereferencing & pointers).
	*	The declaration of a pointer to type can easily be distinguished from dereferencing a variable (though it does risk ambiguity with multiplication, but hopefully the context is sufficient).
	*	It lends itself to declaring multiple variables on the same line, e.g.:

		```c
		char a, b, * c, * d, ** f, *** g;
		```


*	Variables & arrays should either have an obviously descriptive name or have a comment describing their name. Either way, their purpose should be obvious. E.G.

	```c
	int e, numstr; // Element
	```

*	Variables & arrays of the same type should be declared on the same line--permitted that they and their respective comments fit in 80 spaces. If they don't, they should be split over multiple lines so that they do. E.G.

	```c
	////////////////////////////////////////////////////////////////////////////////
	int main (void) {
		int alpha, beta, gamma, delta; // Greek 'A', Greek 'B', Greek 'G', Greek 'D'
		int epsilon, zeta, eta; // Greek 'E', Greek 'Z', Greek 'E'
	```

*	Arrays don't have spaces in their element list. E.G.

	```c
	int nums[4]; // Numbers
	double dblsndbls[2][2]; // Doubles and doubles of doubles

	nums[0] = 10;
	nums[1] = 20;
	nums[2] = 30;
	nums[3] = 40;

	dblsndbls[0][0] = 0.0;
	dblsndbls[0][1] = 0.1;
	dblsndbls[1][0] = 1.0;
	dblsndbls[1][1] = 1.1;
	```

*	I use the following generic variable names:

	*	Generic void

		```c
		void * v;
		```

	*	Generic char

		```c
		char c;
		```

	*	Generic string

		```c
		char * s;
		//char s[maxstr];
		```

	*	Generic short

		```c
		int sh;
		```

	*	Generic integer

		```c
		int i;
		```

	*	Generic long

		```c
		int l;
		```

	*	Generic float

		```c
		int f;
		```

	*	Generic double

		```c
		int d;
		```

	*	Generic signed integer

		```c
		int si;
		```

	*	Generic unsigned integer

		```c
		int ui;
		```

	*	Generic temporary (for all types, but in this case a char)

		```c
		int t;
		```

Functions
---------

*	After initially following IBM's spacey style, e.g.

	```c
	printf( "hello\n" );
	```

	I finally broke down. Intellectually, I agree with it wholeheartedly, as it does solve a lot of style problems very neatly. However, in practice I find that it makes for hideous code. As a result, I make a conceptual distinction between functions that have a contextually relevant return value, and those that don't:

	*	The former have their aguments tightly bound to the function name when it is called. This way, complex expressions containing functions with return values are easier to parse. E.G.

		```c
		double x = 3 + 7 * (log(10) / log(2));
		```

	*	The latter are not tightly bound to the function name when it is called. This way, the code reads more like a natural language. E.G.

		```c
		printf ("Hello, boy. Hahahahahahaha!!!\n"); // Why, yes, I *am* a big fan of Cowboy Bebop!
		```

*	Nested parentheses do not receive a space. This is hard on the eyes, sure, but a decent text editor overcomes this easily.

	```c
	printf ("%d\n", pow(2, 3));
	```

*	Per K & R, empty lists should be made explicit with *void*, e.g.:

	```c
	int main (void) {
		int x = 1337;

		return 0;
	}

Control Functions
-----------------

*	Control functions are not tightly bound to their arguments, e.g.

	```c
	if (x > 1) {
		printf ("%f\n", 2 * 3 / log(8));
	}
	```

*	Multi-liners should use curly braces, per the following:

	```c
	if (x == 1) {
		printf ("x == 1, yay!\n");
		printf ("I am so bored...!\n");
	}
	```

	This way the indentation is more meaningful.

*	The `else` function follows this convention, too. E.G.:

	```c
	if (x == 1) {
		printf ("x == 1, yay!\n");
		printf ("I am so bored...!\n");
	} else if (x == 2) {
		printf ("x == 2, wooooo!\n");
		printf ("Yup, really bored...!\n");
	} else {
		printf ("x != 1, booo...\n");
		printf ("I am still bored...!\n");
	}
	```

	(My previous style was simply too verbose. Also, it separated the control function too much from it's body.)

*	Control functions one-liners follow the K & R style. E.G.

	```c
	if (x == 1)
		printf ("%d == 1, yay!\n", x);
	```

	The exception is the body-less loop. E.G. 

	```c
	for (i = 0; s[i] != '\0' && s[i] != '\n'; ++i);
	```

Comments
--------

*	Sections are demarcated by 80 `/`'s, followed by a commented section name and a blank line. E.G.:

	```C
	////////////////////////////////////////////////////////////////////////////////
	// Comments

	// This is the first item in this section
	```

*	I make an effort to not exceed 80 characters per line.

*	The `main` section is special, in that it only has the horizontal "bar". E.G.:

	```C
	////////////////////////////////////////////////////////////////////////////////
	int main (void) {
		printf ("Wut?!\n");
	```

	This is because the `main` is very obvious.

*	Comments in the comments section should be separate by at least one line break. If they are sufficiently decoupled, two. Both should be commented out with a `//`.

	```C
	////////////////////////////////////////////////////////////////////////////////
	// Comments

	// This is a dummy comment section.
	// I feel like a dummy...

	// Syria is still in a state of civil war.
	```

*	Comments that only refer to one line should be placed to the right of the code, and commented out with `//`. E.G.:

	```c
	free (s); // Always free memory
	```

*	Code block description comments should be commented out with `//`, a description, a `{{{`, and at the end of the block a `// }}}`. E.G.:

	```c
	// Prints 'Hello, world' {{{
	char s[] = "Hello, world\n";
	printf ("%s", s);
	// }}}
	```

*	Function prototypes--especially as they appear in header files--should have a thorough description of the function, encased in multi-line comment demarcators, right below the function prototype. E.G.:

	```c
	float add (float x, float y);
	/* Adds the two arguments together.

	`x` = The first value to be added.

	`y` = The second value to be added.

	Returns the sum of the two values. */
	```

*	In general, give variables descriptive comments at their declaration, e.g.:

	```c
	int main (void) {
		int c; // Character

		while ((c = getchar()) != EOF)
			printf ("Character = [%c]\n", c);

		return 0;
	}
	```

*	Non-obvious code-blocks should have a comment describing the action taking place, so that when you come back to it in 3 months, it doesn't look like [Linear B](https://en.wikipedia.org/wiki/Linear_B). E.G. same as the above example, but with a description:

	```c
	int main (void) {
		int c; // Character

		// Reads one character at a time from STDIN and prints it to STDOUT
		while ((c = getchar()) != EOF)
			printf ("Character = [%c]\n", c);

		return 0;
	}
	```

*	For overlong, single line comments, break the comment into multiple lines so that they fit within the 80 spaces. Each line after the first gets indented same as the first, then filled with spaces so that the `//` line up. E.G.

	```c
	////////////////////////////////////////////////////////////////////////////////
	int main (void) {
		int e; // Element

		for (e = 12; e < 24; ++e) { // 1 tabs
			printf ("e = [%d]\n"); // 2 tabs: Nothing special about this comment,
			                       // 2 tabs + 23 spaces: except that it is long
			printf ("e != [%d]\n", e - 3); // 2 tabs
		} // 1 tabs
	```

Organization
------------

*	Small, single-file programs are organized accordingly:
	1.	Comments
	2.	Libraries
	3.	Symbolic Constants
	4.	Macros
	5.	Structs
	6.	External Variables
	7.	Function Prototypes
	8.	Functions
	9.	Main

*	Large, multi-file programs are organized as follows:
	*	Each file gets a *Comments* section.
	*	Header files get the Symbolic Constants, Macros, External Variables, and Functional Prototypes (and occasionally also any relevant *#include*'s, e.g. *stddef.h* when using funky types).
	*	Function files get Functions and their necessary *#include*'s.
	*	A main file gets the main function and any necessary *#include*'s.

	Since large projects are organized differently depending on the size and use, this is just a general guide (for instance, a function file may call on a function in another file, the function of which may call on yet another function in yet another file).

Variable & Function Naming
--------------------------

I have yet to determine variable & function naming conventions. C convention generally runs towards minimal length (e.g. 's' to indicate a variable for a string), apparently because back in the good ol' days vars couldn't be longer than 8 bits or some such. Clearly we're past that, but the convention has stuck. Most times, this isn't a problem, but sometimes it makes code unreadable. Accordingly, I've toyed with going with the first letters of a short description separated by underscores (e.g. "dynamic string" = 'd\_s'), full descriptive names (e.g. 'dynamic\_string'), etc. I'm still undecided what I'm going to go with. I'll update this section when I develop some kind of preference.
